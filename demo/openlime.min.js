!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).OpenLIME={})}(this,(function(t){"use strict";class e{constructor(t){Object.assign(this,{xLow:1e20,yLow:1e20,xHigh:-1e20,yHigh:-1e20}),Object.assign(this,t)}fromArray(t){this.xLow=t[0],this.yLow=t[1],this.xHigh=t[2],this.yHigh=t[3]}toEmpty(){this.xLow=1e20,this.yLow=1e20,this.xHigh=-1e20,this.yHigh=-1e20}isEmpty(){return this.xLow>this.xHigh||this.yLow>this.yHigh}toArray(){return[this.xLow,this.yLow,this.xHigh,this.yHigh]}toString(){return this.xLow.toString()+" "+this.yLow.toString()+" "+this.xHigh.toString()+" "+this.yHigh.toString()}mergeBox(t){if(null==t)return this;this.xLow=Math.min(this.xLow,t.xLow),this.yLow=Math.min(this.yLow,t.yLow),this.xHigh=Math.max(this.xHigh,t.xHigh),this.yHigh=Math.max(this.yHigh,t.yHigh)}mergePoint(t){this.xLow=Math.min(this.xLow,t.x),this.yLow=Math.min(this.yLow,t.y),this.xHigh=Math.max(this.xHigh,t.x),this.yHigh=Math.max(this.yHigh,t.y)}shift(t,e){this.xLow+=t,this.yLow+=e,this.xHigh+=t,this.yHigh+=e}quantize(t){this.xLow=Math.floor(this.xLow/t),this.yLow=Math.floor(this.yLow/t),this.xHigh=Math.floor((this.xHigh-1)/t)+1,this.yHigh=Math.floor((this.yHigh-1)/t)+1}width(){return this.xHigh-this.xLow}height(){return this.yHigh-this.yLow}center(){return[(this.xLow+this.xHigh)/2,(this.yLow+this.yHigh)/2]}corner(t){let e=this.toArray();return[e[0+(1&t)<<1],e[1+(2&t)]]}print(){console.log("BOX="+this.xLow.toFixed(2)+", "+this.yLow.toFixed(2)+", "+this.xHigh.toFixed(2)+", "+this.yHigh.toFixed(2))}}class i{constructor(t){Object.assign(this,{x:0,y:0,z:1,a:0,t:0}),this.t||(this.t=performance.now()),"object"==typeof t&&Object.assign(this,t)}copy(){let t=new i;return Object.assign(t,this),t}apply(t,e){let s=i.rotate(t,e,this.a);return{x:s.x*this.z+this.x,y:s.y*this.z+this.y}}inverse(){let t=i.rotate(this.x/this.z,this.y/this.z,-this.a);return new i({x:-t.x,y:-t.y,z:1/this.z,a:-this.a,t:this.t})}static normalizeAngle(t){for(;t>360;)t-=360;for(;t<0;)t+=360;return t}static rotate(t,e,i){return i=Math.PI*(i/180),{x:Math.cos(i)*t+Math.sin(i)*e,y:-Math.sin(i)*t+Math.cos(i)*e}}compose(t){let e=this.copy(),s=t;e.z*=s.z,e.a+=s.a;var r=i.rotate(e.x,e.y,s.a);return e.x=r.x*s.z+s.x,e.y=r.y*s.z+s.y,e}transformBox(t){let i=new e;for(let e=0;e<4;e++){let s=t.corner(e),r=this.apply(s[0],s[1]);i.mergePoint(r)}return i}getInverseBox(t){let i=this.inverse(),s=[{x:t.x,y:t.y},{x:t.x+t.dx,y:t.y},{x:t.x,y:t.y+t.dy},{x:t.x+t.dx,y:t.y+t.dy}],r=new e;for(let e of s){let s=i.apply(e.x-t.w/2,e.y-t.h/2);r.mergePoint(s)}return r}interpolate(t,e,i){let s=e.t-t.t;if(this.t=i,i<t.t)return Object.assign(this,t);if(i>e.t||s<1e-4)return Object.assign(this,e);let r=(i-t.t)/s,n=(e.t-i)/s;for(let i of["x","y","z","a"])this[i]=n*t[i]+r*e[i]}projectionMatrix(t){let e=this.z,i=2/t.dx,s=2/t.dy,r=i*this.x+2/t.dx*(t.w/2-t.x)-1,n=-s*this.y+2/t.dy*(t.h/2-t.y)-1,a=Math.PI*this.a/180;return[Math.cos(a)*i*e,Math.sin(a)*s*e,0,0,-Math.sin(a)*i*e,Math.cos(a)*s*e,0,0,0,0,1,0,r,n,0,1]}toMatrix(){let t=this.z;return[t,0,0,0,0,t,0,0,0,0,1,0,t*x,t*y,0,1]}sceneToViewportCoords(t,e){return[e[0]*this.z+this.x-t.x+t.w/2,e[1]*this.z-this.y+t.y+t.h/2]}viewportToSceneCoords(t,e){return[(e[0]+t.x-t.w/2-this.x)/this.z,(e[1]-t.y-t.h/2+this.y)/this.z]}}class s{constructor(t){Object.assign(this,{viewport:null,bounded:!0,minScreenFraction:1,maxFixedZoom:2,maxZoom:2,minZoom:1,boundingBox:new e,signals:{update:[]}}),Object.assign(this,t),this.target=new i(this.target),this.source=this.target.copy()}copy(){let t=new s;return Object.assign(t,this),t}addEvent(t,e){this.signals[t].push(e)}emit(t){for(let e of this.signals[t])e(this)}setViewport(t){if(this.viewport){let e=Math.sqrt(t.w/this.viewport.w*(t.h/this.viewport.h));this.viewport=t;const{x:i,y:s,z:r,a:n}=this.target;this.setPosition(0,i,s,r*e,n)}else this.viewport=t}mapToScene(t,e,s){t-=this.viewport.w/2,e-=this.viewport.h/2,t-=s.x,e-=s.y,t/=s.z,e/=s.z;let r=i.rotate(t,e,-s.a);return{x:r.x,y:r.y}}setPosition(t,e,s,r,n){if(Math.abs(e)>64e3||Math.abs(s)>64e3)return;if(this.bounded){const t=this.viewport.dx,a=this.viewport.dy;let o=new i({x:e,y:s,z:r,a:n,t:0}).transformBox(this.boundingBox);const h=o.width(),l=o.height(),c=Math.abs(h-t)/2;e=Math.min(Math.max(-c,e),c);const u=Math.abs(l-a)/2;s=Math.min(Math.max(-u,s),u)}let a=performance.now();this.source=this.getCurrentTransform(a),n=i.normalizeAngle(n),this.source.a=i.normalizeAngle(this.source.a),n-this.source.a>180&&(this.source.a+=360),this.source.a-n>180&&(this.source.a-=360),Object.assign(this.target,{x:e,y:s,z:r,a:n,t:a+t}),this.emit("update")}pan(t,e,i){let s=performance.now(),r=this.getCurrentTransform(s);r.dx+=e,r.dy+=i}zoom(t,e,i,s){i||(i=0),s||(s=0);let r=performance.now(),n=this.getCurrentTransform(r);this.bounded&&(e=Math.min(Math.max(e,this.minZoom),this.maxZoom)),n.x+=(n.x+i)*(n.z-e)/n.z,n.y+=(n.y+s)*(n.z-e)/n.z,this.setPosition(t,n.x,n.y,e,n.a)}rotate(t,e){let i=performance.now(),s=this.getCurrentTransform(i);this.setPosition(t,s.x,s.y,s.z,this.target.a+e)}deltaZoom(t,e,s,r){s||(s=0),r||(r=0);let n=performance.now(),a=this.getCurrentTransform(n);e*=this.target.z/a.z,this.bounded&&(a.z*e<this.minZoom&&(e=this.minZoom/a.z),a.z*e>this.maxZoom&&(e=this.maxZoom/a.z));let o=i.rotate(s,r,a.a);a.x+=o.x*a.z*(1-e),a.y+=o.y*a.z*(1-e),this.setPosition(t,a.x,a.y,a.z*e,a.a)}getCurrentTransform(t){let e=new i;return t<this.source.t&&Object.assign(e,this.source),t>=this.target.t?Object.assign(e,this.target):e.interpolate(this.source,this.target,t),e.t=t,e}fit(t,e,i){if(t.isEmpty())return;e||(e=0);let s=this.viewport.dx,r=this.viewport.dy;t.print();let n=t.width(),a=t.height(),o=t.center(),h=Math.min(s/n,r/a);this.setPosition(e,-o[0],-o[1],h,0)}fitCameraBox(t){this.fit(this.boundingBox,t)}updateBounds(t,e){this.boundingBox=t;const i=this.viewport.dx,s=this.viewport.dy;let r=this.boundingBox.width(),n=this.boundingBox.height();this.minZoom=Math.min(i/r,s/n)*this.minScreenFraction,this.maxZoom=e>0?this.maxFixedZoom/e:this.maxFixedZoom}}class r{constructor(t){Object.assign(this,{type:"vec3",colorSpace:"linear",attribute:"kd"}),Object.assign(this,t)}loadImage(t,e,i){(async()=>{let s={};t.end&&(s.headers={range:`bytes=${t.start}-${t.end}`});var r=await fetch(t.url,s);if(!r.ok)return console.log(),void i("Failed loading "+url+": "+r.statusText);let n=await r.blob();if("undefined"!=typeof createImageBitmap){"undefined"!=typeof InstallTrigger?createImageBitmap(n).then((t=>this.loadTexture(e,t,i))):createImageBitmap(n,{imageOrientation1:"flipY"}).then((t=>this.loadTexture(e,t,i)))}else{let t=window.URL||window.webkitURL,s=document.createElement("img");s.onerror=function(t){console.log("Texture loading error!")},s.src=t.createObjectURL(n),s.onload=function(){t.revokeObjectURL(s.src),this.loadTexture(e,s,i)}}})().catch((t=>{i(null)}))}loadTexture(t,e,i){this.width=e.width,this.height=e.height;var s=t.createTexture();t.bindTexture(t.TEXTURE_2D,s),t.texParameterf(t.TEXTURE_2D,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameterf(t.TEXTURE_2D,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_2D,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.texImage2D(t.TEXTURE_2D,0,t.RGB,t.RGB,t.UNSIGNED_BYTE,e),i(s,e.width*e.height*3)}}class n{constructor(t){Object.assign(this,{version:100,samplers:[],uniforms:{},name:"",body:"",program:null,modes:[],needsUpdate:!0,signals:{update:[]}}),Object.assign(this,t)}setEvent(t,e){this.signals[t]=[e]}emit(t){for(let e of this.signals[t])e(this)}restoreWebGL(t){this.createProgram(t)}setUniform(t,e){let i=this.uniforms[t];i.value=e,i.needsUpdate=!0,this.emit("update")}createProgram(t){let e=t.createShader(t.VERTEX_SHADER);t.shaderSource(e,this.vertShaderSrc(100)),t.compileShader(e);let i=t.getShaderParameter(e,t.COMPILE_STATUS);if(!i)throw console.log(t.getShaderInfoLog(e)),Error("Failed vertex shader compilation: see console log and ask for support.");let s=t.createShader(t.FRAGMENT_SHADER);t.shaderSource(s,this.fragShaderSrc()),t.compileShader(s),this.program&&t.deleteProgram(this.program);let r=t.createProgram();if(t.getShaderParameter(s,t.COMPILE_STATUS),i=t.getShaderParameter(s,t.COMPILE_STATUS),!i)throw console.log(this.fragShaderSrc()),console.log(t.getShaderInfoLog(s)),Error("Failed fragment shader compilation: see console log and ask for support.");if(t.attachShader(r,e),t.attachShader(r,s),t.linkProgram(r),!t.getProgramParameter(r,t.LINK_STATUS)){var n=t.getProgramInfoLog(r);throw new Error("Could not compile WebGL program. \n\n"+n)}for(let e of this.samplers)e.location=t.getUniformLocation(r,e.name);this.coordattrib=t.getAttribLocation(r,"a_position"),t.vertexAttribPointer(this.coordattrib,3,t.FLOAT,!1,0,0),t.enableVertexAttribArray(this.coordattrib),this.texattrib=t.getAttribLocation(r,"a_texcoord"),t.vertexAttribPointer(this.texattrib,2,t.FLOAT,!1,0,0),t.enableVertexAttribArray(this.texattrib),this.matrixlocation=t.getUniformLocation(r,"u_matrix"),this.program=r,this.needsUpdate=!1;for(let t of Object.values(this.uniforms))t.location=null,t.needsUpdate=!0}updateUniforms(t,e){performance.now();for(const[i,s]of Object.entries(this.uniforms))if(s.location||(s.location=t.getUniformLocation(e,i)),s.location&&s.needsUpdate){let e=s.value;switch(s.type){case"vec4":t.uniform4fv(s.location,e);break;case"vec3":t.uniform3fv(s.location,e);break;case"vec2":t.uniform2fv(s.location,e);break;case"float":t.uniform1f(s.location,e);break;case"int":t.uniform1i(s.location,e);break;default:throw Error("Unknown uniform type: "+u.type)}}}vertShaderSrc(){return"#version 300 es\n\nprecision highp float; \nprecision highp int; \n\nuniform mat4 u_matrix;\nin vec4 a_position;\nin vec2 a_texcoord;\n\nout vec2 v_texcoord;\n\nvoid main() {\n\tgl_Position = u_matrix * a_position;\n\tv_texcoord = a_texcoord;\n}"}fragShaderSrc(){return this.body}}class a{constructor(t,e,i){Object.assign(this,{type:e,width:0,height:0,tilesize:256,overlap:0,nlevels:1,tiles:[],suffix:"jpg",qbox:[],bbox:[],signals:{ready:[],updateSize:[]},status:null}),i&&Object.assign(this,i),"string"==typeof t&&(this.url=t,(async()=>{switch(this.type){case"image":await this.initImage();break;case"google":await this.initGoogle();break;case"deepzoom1px":await this.initDeepzoom(!0);break;case"deepzoom":await this.initDeepzoom(!1);break;case"tarzoom":await this.initTarzoom();break;case"zoomify":await this.initZoomify();break;case"iiif":await this.initIIIF()}this.initBoxes(),this.status="ready",this.emit("ready")})().catch((t=>{console.log(t),this.status=t}))),"object"==typeof t&&Object.assign(this,t)}addEvent(t,e){this.signals[t].push(e)}emit(t){for(let e of this.signals[t])e(this)}isReady(){return"ready"==this.status&&this.width&&this.height}boundingBox(){if(!this.width)throw"Layout not initialized still";return new e({xLow:-this.width/2,yLow:-this.height/2,xHigh:this.width/2,yHigh:this.height/2})}index(t,e,i){let s=0;for(let e=0;e<t;e++)s+=this.qbox[e].xHigh*this.qbox[e].yHigh;return s+i*this.qbox[t].xHigh+e}initBoxes(){this.qbox=[],this.bbox=[];var t=this.width,i=this.height;if("image"==this.type)return this.qbox[0]=new e({xLow:0,yLow:0,xHigh:1,yHigh:1}),this.bbox[0]=new e({xLow:0,yLow:0,xHigh:t,yHigh:i}),this.tiles.push({index:0,level:0,x:0,y:0}),this.emit("updateSize"),1;let s=[];for(let r=this.nlevels-1;r>=0;r--){this.qbox[r]=new e({xLow:0,yLow:0,xHigh:0,yHigh:0}),this.bbox[r]=new e({xLow:0,yLow:0,xHigh:t,yHigh:i});for(let e=0;e*this.tilesize<i;e++){this.qbox[r].yHigh=e+1;for(let i=0;i*this.tilesize<t;i++)this.qbox[r].xHigh=i+1,s.push({level:r,x:i,y:e})}t>>>=1,i>>>=1}this.tiles=[];for(let t of s){let e=this.index(t.level,t.x,t.y);t.index=e,this.tiles[e]=t}this.emit("updateSize")}tileCoords(t,e,i){let s=this.width,r=this.height;var n=new Float32Array([0,1,0,0,1,0,1,1]);if("image"==this.type)return{coords:new Float32Array([-s/2,-r/2,0,-s/2,r/2,0,s/2,r/2,0,s/2,-r/2,0]),tcoords:n};let a=new Float32Array([0,0,0,0,1,0,1,1,0,1,0,0]),o=this.nlevels-1-t,h=this.tilesize*(1<<o),l=h,c=h;h*(e+1)>this.width&&(l=this.width-h*e,"google"==this.type&&(n[4]=n[6]=l/h)),h*(i+1)>this.height&&(c=this.height-h*i,"google"==this.type&&(n[1]=n[7]=c/h));var u=this.qbox[t].xHigh-1,d=this.qbox[t].yHigh-1,p=this.overlap;if(p){let t=p/(l/(1<<o)+(0==e?0:p)+(e==u?0:p)),s=p/(c/(1<<o)+(0==i?0:p)+(i==d?0:p));n[0]=n[2]=0==e?0:t,n[3]=n[5]=0==i?0:s,n[4]=n[6]=e==u?1:1-t,n[1]=n[7]=i==d?1:1-s}let m=n[1];n[1]=n[7]=n[3],n[3]=n[5]=m;for(let t=0;t<a.length;t+=3)a[t]=a[t]*l+h*e-this.width/2,a[t+1]=-a[t+1]*c-h*i+this.height/2;return{coords:a,tcoords:n}}neededBox(t,i,s,r){if("image"==this.type)return{level:0,pyramid:[new e({xLow:0,yLow:0,xHigh:1,yHigh:1})]};let n=Math.max(0,Math.min(Math.floor(-Math.log2(i.z)+r),this.nlevels-1)),a=this.nlevels-1-n,o=i.getInverseBox(t);o.shift(this.width/2,this.height/2);let h=[];for(let t=0;t<=a;t++){let i=this.nlevels-1-t,r=this.tilesize*Math.pow(2,i),n=new e(o);n.quantize(r),n.xLow=Math.max(n.xLow-s,this.qbox[t].xLow),n.yLow=Math.max(n.yLow-s,this.qbox[t].yLow),n.xHigh=Math.min(n.xHigh+s,this.qbox[t].xHigh),n.yHigh=Math.min(n.yHigh+s,this.qbox[t].yHigh),h[t]=n}return{level:a,pyramid:h}}getTileURL(t,e){throw Error("Layout not defined or ready.")}initImage(){this.getTileURL=(t,e)=>t,this.nlevels=1,this.tilesize=0}initGoogle(t){if(!this.width||!this.height)throw"Google rasters require to specify width and height";this.tilesize=256,this.overlap=0;let e=Math.max(this.width,this.height)/this.tilesize;this.nlevels=Math.ceil(Math.log(e)/Math.LN2)+1,this.getTileURL=(t,e)=>t+"/"+e.level+"/"+e.y+"/"+e.x+"."+this.suffix}async initDeepzoom(t){var e=await fetch(this.url);if(!e.ok)return void(this.status="Failed loading "+this.url+": "+e.statusText);let i=await e.text(),s=(new window.DOMParser).parseFromString(i,"text/xml").documentElement;this.suffix=s.getAttribute("Format"),this.tilesize=parseInt(s.getAttribute("TileSize")),this.overlap=parseInt(s.getAttribute("Overlap"));let r=s.querySelector("Size");this.width=parseInt(r.getAttribute("Width")),this.height=parseInt(r.getAttribute("Height"));let n=Math.max(this.width,this.height)/this.tilesize;this.nlevels=Math.ceil(Math.log(n)/Math.LN2)+1,this.url=this.url.substr(0,this.url.lastIndexOf("."))+"_files/",this.skiplevels=0,t&&(this.skiplevels=Math.ceil(Math.log(this.tilesize)/Math.LN2)),this.getTileURL=(t,e)=>{let i=e.level+this.skiplevels;return(t=t.substr(0,t.lastIndexOf("."))+"_files/")+i+"/"+e.x+"_"+e.y+"."+this.suffix}}async initTarzoom(){var t=await fetch(this.url);if(!t.ok)return void(this.status="Failed loading "+this.url+": "+t.statusText);let e=await t.json();Object.assign(this,e),this.url=this.url.substr(0,this.url.lastIndexOf("."))+".tzb",this.getTileURL=(t,e)=>(e.start=this.offsets[e.index],e.end=this.offsets[e.index+1],t=t.substr(0,t.lastIndexOf("."))+".tzb")}async initZoomify(){this.overlap=0;var t=await fetch(this.url);if(!t.ok)return void(this.status="Failed loading "+this.url+": "+t.statusText);let e=await t.text(),i=(new window.DOMParser).parseFromString(e,"text/xml").documentElement;if(this.tilesize=parseInt(i.getAttribute("TILESIZE")),this.width=parseInt(i.getAttribute("WIDTH")),this.height=parseInt(i.getAttribute("HEIGHT")),!this.tilesize||!this.height||!this.width)throw"Missing parameter files for zoomify!";let s=Math.max(this.width,this.height)/this.tilesize;this.nlevels=Math.ceil(Math.log(s)/Math.LN2)+1,this.url=this.url.substr(0,this.url.lastIndexOf("/")),this.getTileURL=(t,e)=>{let i=e.index>>8;return t=t.substr(0,t.lastIndexOf("/")),this.url+"/TileGroup"+i+"/"+e.level+"-"+e.x+"-"+e.y+"."+this.suffix}}async initIIIF(){this.overlap=0;var t=await fetch(this.url);if(!t.ok)return void(this.status="Failed loading "+this.url+": "+t.statusText);let e=await t.json();this.width=e.width,this.height=e.height,this.nlevels=e.tiles[0].scaleFactors.length,this.tilesize=e.tiles[0].width,this.url=this.url.substr(0,this.url.lastIndexOf("/")),this.getTileURL=(t,e)=>{let i=this.tilesize,s=(parseInt(this.nlevels-1-e.level),Math.pow(2,e.level)),r=e.x*i*s,n=e.y*i*s,a=Math.min(i*s,this.width-r),o=Math.min(i*s,this.height-n),h=i;r+i*s>this.width&&(h=(this.width-r+s-1)/s);let l=i;return n+i*s>this.height&&(l=(this.height-n+s-1)/s),`${t=t.substr(0,t.lastIndexOf("/"))}/${r},${n},${a},${o}/${h},${l}/0/default.jpg`}}}let o=new class{constructor(t){Object.assign(this,{capacity:536870912,size:0,maxRequest:4,requested:0,maxPrefetch:8388608,prefetched:0}),Object.assign(this,t),this.layers=[]}setCandidates(t){this.layers.includes(t)||this.layers.push(t),setTimeout((()=>{this.update()}),0)}update(){if(this.requested>this.maxRequest)return;let t=this.findBestCandidate();if(t){for(;this.size>this.capacity;){let e=this.findWorstTile();if(!e){console.log("BIG problem in the cache");break}if(!(e.tile.time<t.tile.time))return;this.dropTile(e.layer,e.tile)}this.loadTile(t.layer,t.tile)}}findBestCandidate(){let t=null;for(let e of this.layers){if(!e.queue.length)continue;let i=e.queue.shift();(!t||i.time>t.tile.time||i.time==t.tile.time&&i.priority>t.tile.priority)&&(t={layer:e,tile:i})}return t}findWorstTile(){let t=null;for(let e of this.layers)for(let i of e.tiles)0==i.missing&&(!t||i.time<t.tile.time||i.time==t.tile.time&&i.priority<t.tile.priority)&&(t={layer:e,tile:i});return t}loadTile(t,e){this.requested++,t.loadTile(e,(t=>{this.size+=t,this.requested--,this.update()}))}dropTile(t,e){for(let i=0;i<e.tex.length;i++)e.tex[i]&&(t.gl.deleteTexture(e.tex[i]),e.tex[i]=null,e.missing++);this.size-=e.size,e.size=0}flush(){}flush(t){}};class h{constructor(t){if(t.type){let e=t.type;if(delete t.type,e in this.types)return this.types[e](t);throw"Layer type: "+e+"  module has not been loaded"}this.init(t)}init(t){Object.assign(this,{transform:new i,visible:!0,zindex:0,opacity:1,rasters:[],layers:[],controls:{},controllers:[],shaders:{},layout:"image",shader:null,gl:null,prefetchBorder:1,mipmapBias:.5,maxRequest:4,signals:{update:[],ready:[],updateSize:[]},tiles:[],queue:[],requested:{}}),Object.assign(this,t),this.transform=new i(this.transform)}addEvent(t,e){this.signals[t].push(e)}emit(t){for(let e of this.signals[t])e(this)}setLayout(t){let e=()=>{for(let t of this.rasters)if("ready"!=t.layout.status)return void t.layout.addEvent("ready",e);this.status="ready",this.setupTiles(),this.emit("ready"),this.emit("update")};"ready"==t.status?e():t.addEvent("ready",e),this.layout=t,this.layout.addEvent("updateSize",(()=>{this.emit("updateSize")}))}setTransform(t){this.transform=t,this.emit("updateSize")}setShader(t){if(!t in this.shaders)throw"Unknown shader: "+t;this.shader=this.shaders[t],this.setupTiles(),this.shader.setEvent("update",(()=>{this.emit("update")}))}getMode(){return this.shader.mode}getModes(){return this.shader?this.shader.modes:[]}setMode(t){this.shader.setMode(t),this.emit("update")}setVisible(t){this.visible=t,this.previouslyNeeded=null,this.emit("update")}setZindex(t){this.zindex=t,this.emit("update")}static computeLayersMinScale(t,e){if(null==t||null==t)return console.log("ASKING SCALE INFO ON NO LAYERS"),1;let i=1;for(let s of Object.values(t))if(!e||s.visible){let t=s.scale();i=Math.min(i,t)}return i}scale(){return this.transform.z}boundingBox(){let t=this.layout.boundingBox();return null!=this.transform&&null!=this.transform&&(t=this.transform.transformBox(t)),t}static computeLayersBBox(t,i){if(null==t||null==t){return console.log("ASKING BBOX INFO ON NO LAYERS"),new e}let s=new e;for(let e of Object.values(t))if((!i||e.visible)&&e.layout.width){const t=e.boundingBox();s.mergeBox(t)}return s}setControl(t,e,i){let s=performance.now(),r=this.controls[t];this.interpolateControl(r,s),r.source.value=[...r.current.value],r.source.t=s,r.target.value=[...e],r.target.t=s+i,this.emit("update")}interpolateControls(){let t=performance.now(),e=!0;for(let i of Object.values(this.controls))e=this.interpolateControl(i,t)&&e;return e}interpolateControl(t,e){let i=t.source,s=t.target,r=t.current;if(r.t=e,e<i.t)return r.value=[...i.value],!1;if(e>s.t-1e-4){let t=r.value.every(((t,e)=>t===s.value[e]));return r.value=[...s.value],t}let n=s.t-i.t,a=(e-i.t)/n,o=(s.t-e)/n;r.value=[];for(let t=0;t<i.value.length;t++)r.value[t]=o*i.value[t]+a*s.value[t];return!1}clear(){this.ibuffer=this.vbuffer=null,this.tiles=[],this.setupTiles(),this.queue=[],this.previouslyNeeded=!1,this.prefetch()}draw(t,e){if("ready"==!this.status||0==this.tiles.length)return;if(!this.shader)throw"Shader not specified!";let i=this.interpolateControls();this.prepareWebGL(),t=this.transform.compose(t);let s=this.layout.neededBox(e,t,0,this.mipmapBias),r=this.toRender(s),n=t.projectionMatrix(e);this.gl.uniformMatrix4fv(this.shader.matrixlocation,this.gl.FALSE,n);for(let t in r){r[t];this.drawTile(r[t])}return i}drawTile(t){let e=this.tiles[t.index];if(0!=e.missing)throw"Attempt to draw tile still missing textures";let i=this.layout.tileCoords(t.level,t.x,t.y);this.updateTileBuffers(i.coords,i.tcoords);let s=this.gl;for(var r=0;r<this.shader.samplers.length;r++){let t=this.shader.samplers[r].id;s.uniform1i(this.shader.samplers[r].location,r),s.activeTexture(s.TEXTURE0+r),s.bindTexture(s.TEXTURE_2D,e.tex[t])}s.drawElements(s.TRIANGLES,6,s.UNSIGNED_SHORT,0)}toRender(t){var e={},i={};let s=t.level;for(var r=t.pyramid[s],n=r.yLow;n<r.yHigh;n++)for(var a=r.xLow;a<r.xHigh;a++)for(var o=s;o>=0;){var h=s-o,l=this.layout.index(o,a>>h,n>>h);if(0==this.tiles[l].missing){e[l]={index:l,level:o,x:a>>h,y:n>>h,complete:!0};break}var c=a>>h+1<<1,u=n>>h+1<<1;i[this.layout.index(o,c,u)]=1,i[this.layout.index(o,c+1,u)]=1,i[this.layout.index(o,c+1,u+1)]=1,i[this.layout.index(o,c,u+1)]=1,o--}for(let t in i)t in e&&(e[t].complete=!1);return e}updateTileBuffers(t,e){let i=this.gl;i.bindBuffer(i.ARRAY_BUFFER,this.vbuffer),i.bufferData(i.ARRAY_BUFFER,t,i.STATIC_DRAW),i.vertexAttribPointer(this.shader.coordattrib,3,i.FLOAT,!1,0,0),i.enableVertexAttribArray(this.shader.coordattrib),i.bindBuffer(i.ARRAY_BUFFER,this.tbuffer),i.bufferData(i.ARRAY_BUFFER,e,i.STATIC_DRAW),i.vertexAttribPointer(this.shader.texattrib,2,i.FLOAT,!1,0,0),i.enableVertexAttribArray(this.shader.texattrib)}setupTiles(){if(this.shader&&this.layout&&"ready"==this.layout.status)if(this.tiles.length)for(let t of this.tiles){t.missing=this.shader.samplers.length;for(let e of this.shader.samplers)t.tex[e.id]&&t.missing--}else{this.tiles=JSON.parse(JSON.stringify(this.layout.tiles));for(let t of this.tiles)t.tex=new Array(this.shader.samplers.length),t.missing=this.shader.samplers.length,t.size=0}}prepareWebGL(){let t=this.gl;this.shader.needsUpdate&&this.shader.createProgram(t),t.useProgram(this.shader.program),this.shader.updateUniforms(t,this.shader.program),this.ibuffer||(this.ibuffer=t.createBuffer(),t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.ibuffer),t.bufferData(t.ELEMENT_ARRAY_BUFFER,new Uint16Array([3,2,1,3,1,0]),t.STATIC_DRAW),this.vbuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.vbuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,0,0,1,0,1,1,0,1,0,0]),t.STATIC_DRAW),this.tbuffer=t.createBuffer(),t.bindBuffer(t.ARRAY_BUFFER,this.tbuffer),t.bufferData(t.ARRAY_BUFFER,new Float32Array([0,0,0,1,1,1,1,0]),t.STATIC_DRAW))}sameNeeded(t,e){return t.level==e.level&&t.pyramid[t.level][0]==e.pyramid[t.level][0]&&t.pyramid[t.level][1]==e.pyramid[t.level][1]&&t.pyramid[t.level][2]==e.pyramid[t.level][2]&&t.pyramid[t.level][3]==e.pyramid[t.level][3]}prefetch(t,e){if(0!=this.layers.length)for(let i of this.layers)i.prefetch(t,e);if(0==this.rasters.length)return;if("ready"!=this.status)return;if("object"!=typeof this.layout)throw"AH!";let i=this.layout.neededBox(e,t,this.prefetchBorder,this.mipmapBias);if(this.previouslyNeeded&&this.sameNeeded(this.previouslyNeeded,i))return;this.previouslyNeeded=i,this.queue=[];let s=performance.now();for(let t=0;t<=i.level;t++){let e=i.pyramid[t],r=[];for(let n=e.yLow;n<e.yHigh;n++)for(let a=e.xLow;a<e.xHigh;a++){let e=this.layout.index(t,a,n),o=this.tiles[e];o.time=s,o.priority=i.level-t,0==o.missing||this.requested[e]||r.push(o)}let n=e.center();r.sort((function(t,e){return Math.abs(t.x-n[0])+Math.abs(t.y-n[1])-Math.abs(e.x-n[0])-Math.abs(e.y-n[1])})),this.queue=this.queue.concat(r)}o.setCandidates(this)}loadTile(t,e){if(this.requested[t.index])throw"AAARRGGHHH double request!";this.requested[t.index]=!0;for(let i of this.shader.samplers){let s=this.rasters[i.id];t.url=s.layout.getTileURL(s.url,t),s.loadImage(t,this.gl,((r,n)=>{"image"==this.layout.type&&(this.layout.width=s.width,this.layout.height=s.height,this.layout.initBoxes()),t.size+=n,t.tex[i.id]=r,t.missing--,t.missing<=0&&(this.emit("update"),delete this.requested[t.index],e&&e(n))}))}}}h.prototype.types={};class l{constructor(t,e,i,s){Object.assign(this,{canvasElement:null,preserveDrawingBuffer:!1,gl:null,overlayElement:e,camera:i,layers:{},signals:{update:[],updateSize:[]}}),Object.assign(this,s),this.init(t);for(let t in this.layers)this.addLayer(t,new h(t,this.layers[t]))}addEvent(t,e){this.signals[t].push(e)}emit(t){for(let e of this.signals[t])e(this)}init(t){if(!t)throw"Missing element parameter";if("string"==typeof t&&!(t=document.querySelector(t)))throw"Could not find dom element.";if(!t.tagName)throw"Element is not a DOM element";if("CANVAS"!=t.tagName)throw"Element is not a canvas element";this.canvasElement=t;let e={antialias:!1,depth:!1,preserveDrawingBuffer:this.preserveDrawingBuffer};if(this.gl=this.gl||t.getContext("webgl2",e)||t.getContext("webgl",e)||t.getContext("experimental-webgl",e),!this.gl)throw"Could not create a WebGL context";t.addEventListener("webglcontextlost",(t=>{console.log("Context lost."),t.preventDefault()}),!1),t.addEventListener("webglcontextrestored",(()=>{this.restoreWebGL()}),!1),document.addEventListener("visibilitychange",(t=>{this.gl.isContextLost()&&this.restoreWebGL()}))}restoreWebGL(){let t={antialias:!1,depth:!1,preserveDrawingBuffer:this.preserveDrawingBuffer};this.gl=this.gl||canvas.getContext("webgl2",t)||canvas.getContext("webgl",t)||canvas.getContext("experimental-webgl",t);for(let t of Object.values(this.layers))t.gl=this.gl,t.clear(),t.shader&&t.shader.restoreWebGL(this.gl);this.emit("update")}addLayer(t,e){e.addEvent("update",(()=>{this.emit("update")})),e.addEvent("updateSize",(()=>{this.updateSize()})),e.gl=this.gl,e.overlayElement=this.overlayElement,this.layers[t]=e,this.prefetch()}updateSize(){let t=h.computeLayersBBox(this.layers,true),e=h.computeLayersMinScale(this.layers,true);console.log("Update Scene BBox "+t.xLow.toFixed(2)+" "+t.xHigh.toFixed(2)+" minScale "+e.toFixed(2)),null!=t&&this.camera.updateBounds(t,e),this.emit("updateSize")}draw(t){let e=this.gl,i=this.camera.viewport;e.viewport(i.x,i.y,i.dx,i.dy);var s=[0,0,0,0];e.clearColor(s[0],s[1],s[2],s[3],s[4]),e.clear(e.COLOR_BUFFER_BIT),e.blendFunc(e.SRC_ALPHA,e.ONE_MINUS_SRC_ALPHA),e.enable(e.BLEND);let r=this.camera.getCurrentTransform(t);this.prefetch(r);let n=Object.values(this.layers).sort(((t,e)=>t.zindex-e.zindex)),a=!0;for(let t of n)t.visible&&(a=t.draw(r,i)&&a);return a&&r.t>=this.camera.target.t}prefetch(t){t||(t=this.camera.getCurrentTransform(performance.now()));for(let e in this.layers){let i=this.layers[e];i.visible&&i.prefetch(t,this.camera.viewport)}}}class c extends n{constructor(t){super({}),Object.assign(this,{modes:["light","normals","diffuse","specular"],mode:"normal",type:["ptm","hsh","sh","rbf","bln"],colorspaces:["lrgb","rgb","mrgb","mycc"],nplanes:null,yccplanes:null,njpegs:null,material:null,lights:null,sigma:null,ndimensions:null,scale:null,bias:null,basis:null,lweights:null}),Object.assign(this,t),this.relight&&this.init(this.relight),this.setMode("light")}setMode(t){if(!this.modes.includes(t))throw Error("Unknown mode: "+t);this.mode=t,"light"!=t&&(this.lightWeights([.612,.354,.707],"base"),this.lightWeights([-.612,.354,.707],"base1"),this.lightWeights([0,-.707,.707],"base2")),this.body=this.template(),this.needsUpdate=!0}setLight(t){if(!this.uniforms.light)throw"Shader not initialized, wait on layer ready event for setLight.";let e=t[0],i=t[1],s=Math.sqrt(e*e+i*i);s>1&&(e/=s,i/=s),t=[e,i,Math.sqrt(Math.max(0,1-e*e-i*i))],"light"==this.mode&&this.lightWeights(t,"base"),this.setUniform("light",t)}setSpecularExp(t){this.setUniform("specular_exp",t)}init(t){for(Object.assign(this,t),"mycc"==this.colorspace?this.nplanes=this.yccplanes[0]+this.yccplanes[1]+this.yccplanes[2]:this.yccplanes=[0,0,0],this.planes=[],this.njpegs=0;3*this.njpegs<this.nplanes;)this.njpegs++;for(let t=0;t<this.njpegs;t++)this.samplers.push({id:t,name:"plane"+t,type:"vec3"});this.normals&&this.samplers.push({id:this.njpegs,name:"normals",type:"vec3"}),this.normals&&this.samplers.push({id:this.njpegs,name:"normals",type:"vec3"}),this.material=this.materials[0],this.lights&&(this.lights,new Float32Array(this.lights)),"rbf"==this.type&&(this.ndimensions=this.lights.length/3),"bilinear"==this.type&&(this.ndimensions=this.resolution*this.resolution,this.type="bln"),this.scale=this.material.scale,this.bias=this.material.bias,["mrgb","mycc"].includes(this.colorspace)&&this.loadBasis(this.basis),this.uniforms={light:{type:"vec3",needsUpdate:!0,size:3,value:[0,0,1]},specular_exp:{type:"float",needsUpdate:!1,size:1,value:10},bias:{type:"vec3",needsUpdate:!0,size:this.nplanes/3,value:this.bias},scale:{type:"vec3",needsUpdate:!0,size:this.nplanes/3,value:this.scale},base:{type:"vec3",needsUpdate:!0,size:this.nplanes},base1:{type:"vec3",needsUpdate:!1,size:this.nplanes},base2:{type:"vec3",needsUpdate:!1,size:this.nplanes}},this.lightWeights([0,0,1],"base"),this.body=this.template()}lightWeights(t,e,i){let s;switch(this.type){case"ptm":s=class{static lightWeights(t){let e=[1,t[0],t[1],t[0]*t[0],t[0]*t[1],t[1]*t[1]],i=new Float32Array(18);for(let t=0;t<18;t++)i[3*t]=i[3*t+1]=i[3*t+2]=e[t];return i}}.lightWeights(t);break;case"hsh":s=class{static lightWeights(t){let e=3.1415,i=Math.atan2(t[1],t[0]);i<0&&(i=2*e+i);let s=Math.min(Math.acos(t[2]),e/2-.1),r=Math.cos(i),n=Math.cos(s),a=n*n,o=[1/Math.sqrt(2*e),Math.sqrt(6/e)*(r*Math.sqrt(n-a)),Math.sqrt(3/(2*e))*(2*n-1),Math.sqrt(6/e)*(Math.sqrt(n-a)*Math.sin(i)),Math.sqrt(30/e)*(Math.cos(2*i)*(-n+a)),Math.sqrt(30/e)*(r*(2*n-1)*Math.sqrt(n-a)),Math.sqrt(5/(2*e))*(1-6*n+6*a),Math.sqrt(30/e)*((2*n-1)*Math.sqrt(n-a)*Math.sin(i)),Math.sqrt(30/e)*((-n+a)*Math.sin(2*i))],h=new Float32Array(27);for(let t=0;t<27;t++)h[3*t]=h[3*t+1]=h[3*t+2]=o[t];return h}}.lightWeights(t);break;case"sh":s=class{static lightWeights(t){let e=3.1415,i=.5*Math.sqrt(3/e),s=.5*Math.sqrt(15/e),r=[.5/Math.sqrt(e),i*t[0],i*t[2],i*t[1],s*t[0]*t[1],s*t[0]*t[2],.5*Math.sqrt(5/e)*(3*t[2]*t[2]-1),s*t[1]*t[2],.5*s*(t[1]*t[1]-t[0]*t[0])],n=new Float32Array(27);for(let t=0;t<27;t++)n[3*t]=n[3*t+1]=n[3*t+2]=r[t];return n}}.lightWeights(t);break;case"rbf":s=d.lightWeights(t,this);break;case"bln":s=class{static lightWeights(t,e){let i=e.nplanes,s=Math.abs(t[0])+Math.abs(t[1])+Math.abs(t[2]),r=(t[0]+t[1])/s,n=(t[1]-t[0])/s;r=(r+1)/2,n=(n+1)/2,r*=e.resolution-1,n*=e.resolution-1;let a=Math.min(e.resolution-2,Math.max(0,Math.floor(r))),o=Math.min(e.resolution-2,Math.max(0,Math.floor(n))),h=r-a,l=n-o,c=(1-h)*(1-l),u=h*(1-l),d=(1-h)*l,p=h*l,m=new Float32Array(3*(i+1));for(let t=0;t<i+1;t++)for(let i=0;i<3;i++){let s=e.basePixelOffset(t,a,o,i),r=e.basePixelOffset(t,a+1,o,i),n=e.basePixelOffset(t,a,o+1,i),h=e.basePixelOffset(t,a+1,o+1,i);m[3*t+i]=c*e.basis[s]+u*e.basis[r]+d*e.basis[n]+p*e.basis[h]}return m}}.lightWeights(t,this)}this.setUniform(e,s,i)}baseLightOffset(t,e,i){return 3*(t*this.ndimensions+e)+i}basePixelOffset(t,e,i,s){return 3*(t*this.resolution*this.resolution+(e+i*this.resolution))+s}loadBasis(t){let e=new Uint8Array(t);this.basis=new Float32Array(t.length);for(let t=0;t<this.nplanes+1;t++)for(let i=0;i<this.ndimensions;i++)for(let s=0;s<3;s++){let r=this.baseLightOffset(t,i,s);this.basis[r]=0==t?e[r]/255:(e[r]-127)/this.material.range[t-1]}}template(){let t=`#version 300 es\n\nprecision highp float; \nprecision highp int; \n\n#define np1 ${this.nplanes+1}\n\nin vec2 v_texcoord;\nout vec4 color;\n\nconst mat3 T = mat3(8.1650e-01, 4.7140e-01, 4.7140e-01,\n\t-8.1650e-01, 4.7140e-01,  4.7140e-01,\n\t-1.6222e-08, -9.4281e-01, 4.7140e-01);\n\nuniform vec3 light;\nuniform float specular_exp;\nuniform vec3 bias[np1];\nuniform vec3 scale[np1];\n\nuniform vec3 base[np1];\nuniform vec3 base1[np1];\nuniform vec3 base2[np1];\n`;for(let e=0;e<this.njpegs;e++)t+=`\nuniform sampler2D plane${e};\n`;switch(this.normals&&(t+="\nuniform sampler2D normals;\n"),"mycc"==this.colorspace&&(t+=`\n\nconst int ny0 = ${this.yccplanes[0]};\nconst int ny1 = ${this.yccplanes[1]};\n`),this.colorspace){case"rgb":t+=class{static render(t){let e="\nvec4 render(vec3 base[np1]) {\n\tvec4 rgb = vec4(0, 0, 0, 1);";for(let i=0;i<t;i++)e+=`\n\t{\n\t\tvec4 c = texture(plane${i}, v_texcoord);\n\t\trgb.x += base[${i}].x*(c.x - bias[${i}].x)*scale[${i}].x;\n\t\trgb.y += base[${i}].y*(c.y - bias[${i}].y)*scale[${i}].y;\n\t\trgb.z += base[${i}].z*(c.z - bias[${i}].z)*scale[${i}].z;\n\t}\n`;return e+="\n\treturn rgb;\n}\n",e}}.render(this.njpegs);break;case"mrgb":t+=class{static render(t){let e="\nvec4 render(vec3 base[np1]) {\n\tvec3 rgb = base[0];\n\tvec4 c;\n\tvec3 r;\n";for(let i=0;i<t;i++)e+=`\tc = texture(plane${i}, v_texcoord);\n\tr = (c.xyz - bias[${i}])* scale[${i}];\n\n\trgb += base[${i}*3+1]*r.x;\n\trgb += base[${i}*3+2]*r.y;\n\trgb += base[${i}*3+3]*r.z;\n`;return e+="\n\treturn vec4(rgb, 1);\n}\n",e}}.render(this.njpegs);break;case"mycc":t+=class{static render(t,e){let i="\nvec3 toRgb(vec3 ycc) {\n \tvec3 rgb;\n\trgb.g = ycc.r + ycc.b/2.0;\n\trgb.b = ycc.r - ycc.b/2.0 - ycc.g/2.0;\n\trgb.r = rgb.b + ycc.g;\n\treturn rgb;\n}\n\nvec4 render(vec3 base[np1]) {\n\tvec3 rgb = base[0];\n\tvec4 c;\n\tvec3 r;\n";for(let s=0;s<t;s++)i+=`\n\n\tc = texture(plane${s}, v_texcoord);\n\n\tr = (c.xyz - bias[${s}])* scale[${s}];\n`,i+=s<e?`\n\trgb.x += base[${s}*3+1].x*r.x;\n\trgb.y += base[${s}*3+2].y*r.y;\n\trgb.z += base[${s}*3+3].z*r.z;\n`:`\n\trgb.x += base[${s}*3+1].x*r.x;\n\trgb.x += base[${s}*3+2].x*r.y;\n\trgb.x += base[${s}*3+3].x*r.z;\n`;return i+="\t\n\treturn vec4(toRgb(rgb), 1);\n}\n",i}}.render(this.njpegs,this.yccplanes[0])}if(t+="\n\nvoid main(void) {\n\n","light"==this.mode)t+="\n\tcolor = render(base);\n";else switch(this.normals?t+="\n\tvec3 normal = (texture(normals, v_texcoord).zyx *2.0) - 1.0;\n\tnormal.z = sqrt(1.0 - normal.x*normal.x - normal.y*normal.y);\n":t+="\n\tvec3 normal;\n\tnormal.x = dot(render(base ).xyz, vec3(1));\n\tnormal.y = dot(render(base1).xyz, vec3(1));\n\tnormal.z = dot(render(base2).xyz, vec3(1));\n\tnormal = normalize(T * normal);\n",this.mode){case"normals":t+="\n\tnormal = (normal + 1.0)/2.0;\n\tcolor = vec4(0.0, normal.xy, 1);\n";break;case"diffuse":t+="\n\tcolor = vec4(vec3(dot(light, normal)), 1);\n";break;case"specular":default:t+="\n\tfloat s = pow(dot(light, normal), specular_exp);\n\t//color = vec4(render(base).xyz*s, 1.0);\n\tcolor = vec4(s, s, s, 1.0);\n"}return t+="\n}",t}}class d{static lightWeights(t,e){let i=d.rbf(t,e),s=e.nplanes,r=new Float32Array(3*(s+1));for(let t=0;t<s+1;t++)for(let s=0;s<3;s++)for(let n=0;n<i.length;n++){let a=e.baseLightOffset(t,i[n][0],s);r[3*t+s]+=i[n][1]*e.basis[a]}return r}static rbf(t,e){let i=1/(e.sigma*e.sigma),s=new Array(e.ndimensions),r=0;for(let n=0;n<s.length;n++){let a=e.lights[3*n+0]-t[0],o=e.lights[3*n+1]-t[1],h=e.lights[3*n+2]-t[2],l=a*a+o*o+h*h,c=Math.exp(-i*l);s[n]=[n,c],r+=c}for(let t=0;t<s.length;t++)s[t][1]/=r;let n=0;r=0;for(let t=0;t<s.length;t++)s[t][1]>.001&&(s[n++]=s[t],r+=s[t][1]);s=s.slice(0,n);for(let t=0;t<s.length;t++)s[t][1]/=r;return s}}class p extends h{constructor(t){if(super(t),0!=Object.keys(this.rasters).length)throw"Rasters options should be empty!";if(!this.url)throw"Url option is required";this.layout||(this.layout="image"),this.shaders.rti=new c({normals:this.normals}),this.setShader("rti");let e=performance.now();this.controls.light={source:{value:[0,0],t:e},target:{value:[0,0],t:e},current:{value:[0,0],t:e}},this.worldRotation=0,this.url&&this.loadJson(this.url)}imageUrl(t,e){let i=this.url.substring(0,this.url.lastIndexOf("/")+1);switch(this.layout){case"image":return i+e+".jpg";case"google":return i+e;case"deepzoom":return i+e+".dzi";case"tarzoom":return i+e+".tzi";case"zoomify":return i+e+"/ImageProperties.xml";case"iiif":throw Error("Unimplemented");default:throw Error("Unknown layout: "+layout)}}setLight(t,e){this.setControl("light",t,e)}loadJson(t){(async()=>{var t=await fetch(this.url);if(!t.ok)return void(this.status="Failed loading "+this.url+": "+t.statusText);let e=await t.json();this.shader.init(e);let i={width:this.width,height:this.height};for(let t=0;t<this.shader.njpegs;t++){let e=this.imageUrl(this.url,"plane_"+t),s=new r({url:e,type:"vec3",attribute:"coeff",colorspace:"linear"});0==t||"tarzoom"==this.layout?s.layout=new a(e,this.layout,i):s.layout=this.rasters[0].layout,this.rasters.push(s)}if(this.normals){let t=this.imageUrl(this.url,"normals"),e=new r({url:t,type:"vec3",attribute:"coeff",colorspace:"linear"});e.layout=new a(t,this.layout,i),this.rasters.push(e)}this.setLayout(this.rasters[0].layout)})().catch((t=>{console.log(t),this.status=t}))}interpolateControls(){let t=super.interpolateControls();if(!t){let t=this.controls.light.current.value,e=i.rotate(t[0],t[1],this.worldRotation*Math.PI);this.shader.setLight([e.x,e.y])}return t}draw(t,e){return this.worldRotation=t.a+this.transform.a,super.draw(t,e)}}h.prototype.types.rti=t=>new p(t);class m extends n{constructor(t){super({}),this.modes=["ward","diffuse","specular","normals"],this.mode="ward",this.alphaLimits=[.01,.5],Object.assign(this,t),this.uniforms={uLightInfo:{type:"vec4",needsUpdate:!0,size:4,value:[.1,.1,.9,0]},uAlphaLimits:{type:"vec2",needsUpdate:!0,size:2,value:this.alphaLimits},uInputColorSpaceKd:{type:"int",needsUpdate:!0,size:1,value:this.colorspaces.kd},uInputColorSpaceKs:{type:"int",needsUpdate:!0,size:1,value:this.colorspaces.ks}},this.innerCode="",this.setMode(this.mode),this.body=this.template()}setLight(t){this.setUniform("uLightInfo",t)}setMode(t){switch(this.mode=t,t){case"ward":this.innerCode="vec3 linearColor = (kd + ks * spec) * NdotL;\n\t\t\t\tlinearColor += kd * 0.02; // HACK! adding just a bit of ambient";break;case"diffuse":this.innerCode="vec3 linearColor = kd;";break;case"specular":this.innerCode="vec3 linearColor = clamp((ks * spec) * NdotL, 0.0, 1.0);";break;case"normals":this.innerCode="vec3 linearColor = (N+vec3(1.))/2.;\n\t\t\t\tapplyGamma = false;";break;default:throw console.log("ShaderBRDF: Unknown mode: "+t),Error("ShaderBRDF: Unknown mode: "+t)}}template(){return`#version 300 es\n\nprecision highp float; \nprecision highp int; \n\n#define NULL_NORMAL vec3(0,0,0)\n#define SQR(x) ((x)*(x))\n#define PI (3.14159265359)\n#define ISO_WARD_EXPONENT (4.0)\n\nin vec2 v_texcoord;\nuniform sampler2D uTexKd;\nuniform sampler2D uTexKs;\nuniform sampler2D uTexNormals;\nuniform sampler2D uTexGloss;\n\nuniform vec4 uLightInfo; // [x,y,z,w] (if .w==0 => Directional, if w==1 => Spot)\nuniform vec2 uAlphaLimits;\nuniform int uInputColorSpaceKd; // 0: Linear; 1: sRGB\nuniform int uInputColorSpaceKs; // 0: Linear; 1: sRGB\n\nout vec4 color;\n\nvec3 getNormal(const in vec2 texCoord) {\n\tvec3 n = texture(uTexNormals, texCoord).xyz;\n\tn = 2. * n - vec3(1.);\n\tfloat norm = length(n);\n\tif(norm < 0.5) return NULL_NORMAL;\n\telse return n/norm;\n}\n\nvec3 linear2sRGB(vec3 linearRGB) {\n    bvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n    vec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n    vec3 lower = linearRGB * vec3(12.92);\n    return mix(higher, lower, cutoff);\n}\n\nvec3 sRGB2Linear(vec3 sRGB) {\n    bvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n    vec3 higher = pow((sRGB + vec3(0.055))/vec3(1.055), vec3(2.4));\n    vec3 lower = sRGB/vec3(12.92);\n    return mix(higher, lower, cutoff);\n}\n\nfloat ward(in vec3 V, in vec3 L, in vec3 N, in vec3 X, in vec3 Y, in float alpha) {\n\n\tvec3 H = normalize(V + L);\n\n\tfloat H_dot_N = dot(H, N);\n\tfloat sqr_alpha_H_dot_N = SQR(alpha * H_dot_N);\n\n\tif(sqr_alpha_H_dot_N < 0.00001) return 0.0;\n\n\tfloat L_dot_N_mult_N_dot_V = dot(L,N) * dot(N,V);\n\tif(L_dot_N_mult_N_dot_V <= 0.0) return 0.0;\n\n\tfloat spec = 1.0 / (4.0 * PI * alpha * alpha * sqrt(L_dot_N_mult_N_dot_V));\n\t\n\t//float exponent = -(SQR(dot(H,X)) + SQR(dot(H,Y))) / sqr_alpha_H_dot_N; // Anisotropic\n\tfloat exponent = -SQR(tan(acos(H_dot_N))) / SQR(alpha); // Isotropic\n\t\n\tspec *= exp( exponent );\n\n\treturn spec;\n}\n\n\nvoid main() {\n\tvec3 N = getNormal(v_texcoord);\n\tif(N == NULL_NORMAL) {\n\t\tcolor = vec4(0.0);\n\t\treturn;\n\t}\n\n\tvec3 L = (uLightInfo.w == 0.0) ? normalize(uLightInfo.xyz) : normalize(uLightInfo.xyz - gl_FragCoord.xyz);\n\tvec3 V = vec3(0.0,0.0,1.0);\n    vec3 H = normalize(L + V);\n\tfloat NdotL = max(dot(N,L),0.0);\n\n\tvec3 kd = texture(uTexKd, v_texcoord).xyz;\n\tvec3 ks = texture(uTexKs, v_texcoord).xyz;\n\tif(uInputColorSpaceKd == 1) {\n\t\tkd = sRGB2Linear(kd);\n\t}\n\tif(uInputColorSpaceKs == 1) {\n\t\tks = sRGB2Linear(ks);\n\t}\n\tkd /= PI;\n\n\tfloat gloss = texture(uTexGloss, v_texcoord).x;\n\tfloat minGloss = 1.0 - pow(uAlphaLimits[1], 1.0 / ISO_WARD_EXPONENT);\n\tfloat maxGloss = 1.0 - pow(uAlphaLimits[0], 1.0 / ISO_WARD_EXPONENT);\n\n\tfloat alpha = pow(1.0 - gloss * (maxGloss - minGloss) - minGloss, ISO_WARD_EXPONENT);\n\t\n\t\n\tvec3 e = vec3(0.0,0.0,1.0);\n\tvec3 T = normalize(cross(N,e));\n\tvec3 B = normalize(cross(N,T));\n\tfloat spec = ward(V, L, N, T, B, alpha);\n\t\n\tbool applyGamma = true;\n\n\t${this.innerCode}\n\t\n\tvec3 finalColor = applyGamma ? pow(linearColor * 1.0, vec3(1.0/2.2)) : linearColor;\n\tcolor = vec4(finalColor, 1.0);\n}\n`}}class f extends h{constructor(t){if(super(t),0!=Object.keys(this.rasters).length)throw"Rasters options should be empty!";if(!this.channels)throw"channels option is required";this.colorspaces||(console.log("LayerBRDF: missing colorspaces: force both to linear"),this.colorspaces.kd="linear",this.colorspaces.ks="linear"),this.layout||(this.layout=new a("image")),this.rasters.push(new r({url:this.channels.kd,type:"vec3",attribute:"kd",colorspace:this.colorspaces.kd})),this.rasters.push(new r({url:this.channels.ks,type:"vec3",attribute:"ks",colorspace:this.colorspaces.ks})),this.rasters.push(new r({url:this.channels.normals,type:"vec3",attribute:"normals",colorspace:"linear"})),this.rasters.push(new r({url:this.channels.gloss,type:"float",attribute:"gloss",colorspace:"linear"}));let e={width:this.width,height:this.height};for(let t of this.rasters)t.layout=new a(t.url,this.layout,e);this.setLayout(this.rasters[0].layout);let i=performance.now();this.controls.light={source:{value:[0,0],t:i},target:{value:[0,0],t:i},current:{value:[0,0],t:i}};let s=new m({label:"Rgb",samplers:[{id:0,name:"uTexKd"},{id:1,name:"uTexKs"},{id:2,name:"uTexNormals"},{id:3,name:"uTexGloss"}],colorspaces:this.colorspaces});this.shaders.brdf=s,this.setShader("brdf")}setLight(t,e){this.setControl("light",t,e)}interpolateControls(){let t=super.interpolateControls();if(!t){let t=this.controls.light.current.value,e=Math.sqrt(1-t[0]*t[0]-t[1]*t[1]);this.shader.setLight([t[0],t[1],e,0])}return t}}h.prototype.types.brdf=t=>new f(t);class g{constructor(t){Object.assign(this,{active:!0,debug:!1,panDelay:50,zoomDelay:200,priority:0}),Object.assign(this,t)}captureEvents(){this.capture=!0}releaseEvents(){this.capture=!1}}class v extends g{constructor(t,i){super(i),this.callback=t,this.box||(this.box=new e({xLow:-.99,yLow:-.99,xHigh:.99,yHigh:.99})),this.panning=!1}update(t){let e=t.target.getBoundingClientRect(),i=Math.max(0,Math.min(1,t.offsetX/e.width)),s=Math.max(0,Math.min(1,1-t.offsetY/e.height));i=this.box.xLow+i*this.box.width(),s=this.box.yLow+s*this.box.height(),this.callback(i,s)}panStart(t){this.active&&(this.update(t),this.panning=!0,t.preventDefault())}panMove(t){if(!this.panning)return!1;this.update(t)}panEnd(t){if(!this.panning)return!1;this.panning=!1}fingerSingleTap(t){this.update(t),t.preventDefault()}}class b extends g{constructor(t,e){super(e),this.camera=t,this.zoomAmount=1.2,this.panning=!1,this.initialTransform=null,this.startMouse=null,this.zooming=!1,this.initialDistance=0}panStart(t){if(!this.active||this.panning)return;this.panning=!0,this.startMouse={x:t.offsetX,y:t.offsetY};let e=performance.now();this.initialTransform=this.camera.getCurrentTransform(e),this.camera.target=this.initialTransform.copy(),t.preventDefault()}panMove(t){if(!this.panning)return;let e=this.initialTransform,i=t.offsetX-this.startMouse.x,s=t.offsetY-this.startMouse.y;this.camera.setPosition(this.panDelay,e.x+i,e.y+s,e.z,e.a)}panEnd(t){this.panning=!1}distance(t,e){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}pinchStart(t,e){this.zooming=!0,this.initialDistance=this.distance(t,e),t.preventDefault()}pinchMove(t,e){if(!this.zooming)return;const i=this.distance(t,e),s=this.camera.mapToScene((t.x+e.x)/2,(t.y+e.y)/2,this.camera.getCurrentTransform(performance.now())),r=this.camera.target.z*i/this.initialDistance;this.camera.zoom(this.zoomDelay,r,s.x,s.y),this.initialDistance=i}pinchEnd(t,e,i,s){this.zooming=!1}mouseWheel(t){let e=t.deltaY>0?1:-1;const i=this.camera.mapToScene(t.offsetX,t.offsetY,this.camera.getCurrentTransform(performance.now())),s=Math.pow(this.zoomAmount,e);this.camera.deltaZoom(this.zoomDelay,s,i.x,i.y),t.preventDefault()}fingerDoubleTap(t){const e=this.camera.mapToScene(t.offsetX,t.offsetY,this.camera.getCurrentTransform(performance.now())),i=this.zoomAmount;this.camera.deltaZoom(this.zoomDelay,i,e.x,e.y)}}class w{constructor(t,e){this.target=t,Object.assign(this,{diagonal:27,pinchMaxInterval:200}),e&&Object.assign(this,e),this.currentPointers=[],this.eventObservers=new Map,this.ppmm=w.getPPMM(this.diagonal),this.target.style.touchAction="none",this.target.addEventListener("pointerdown",(t=>this.handleEvent(t)),!1),this.target.addEventListener("pointermove",(t=>this.handleEvent(t)),!1),this.target.addEventListener("pointerup",(t=>this.handleEvent(t)),!1),this.target.addEventListener("pointercancel",(t=>this.handleEvent(t)),!1),this.target.addEventListener("wheel",(t=>this.handleEvent(t)),!1)}static get ANYPOINTER(){return-1}static splitStr(t){return t.trim().split(/\s+/g)}static getPPMM(t){return Math.round(Math.sqrt(screen.width**2+screen.height**2)/t/25.4)}on(t,e,i=w.ANYPOINTER){return t=w.splitStr(t),"function"==typeof e&&((e=Object.fromEntries(t.map((t=>[t,e])))).priority=-1e3),t.forEach((t=>{if(i==w.ANYPOINTER)this.broadcastOn(t,e);else{const s=this.currentPointers[i];if(!s)throw new Error("Bad Index");s.on(t,e)}})),e}off(t,e,i=w.ANYPOINTER){i==w.ANYPOINTER?this.broadcastOff(t,e):w.splitStr(t).forEach((t=>{const s=this.currentPointers[i];if(!s)throw new Error("Bad Index");s.off(t,e)}))}onEvent(t){const e=["fingerHover","fingerSingleTap","fingerDoubleTap","fingerHold","mouseWheel"];if(!t.hasOwnProperty("priority"))throw new Error("Event handler has not priority property");if(!e.some((e=>"function"==typeof t[e])))throw new Error("Event handler properties are wrong or missing");for(let i of e)"function"==typeof t[i]&&this.on(i,t);t.panStart&&this.onPan(t),t.pinchStart&&this.onPinch(t)}onPan(t){if(!t.hasOwnProperty("priority"))throw new Error("Event handler has not priority property");if(!["panStart","panMove","panEnd"].every((e=>"function"==typeof t[e])))throw new Error("Pan handler is missing one of this functions: panStart, panMove or panEnd");t.fingerMovingStart=e=>{t.panStart(e),e.defaultPrevented&&(this.on("fingerMoving",(e=>{t.panMove(e)}),e.idx),this.on("fingerMovingEnd",(e=>{t.panEnd(e)}),e.idx))},this.on("fingerMovingStart",t)}onPinch(t){if(!t.hasOwnProperty("priority"))throw new Error("Event handler has not priority property");if(!["pinchStart","pinchMove","pinchEnd"].every((e=>"function"==typeof t[e])))throw new Error("Pinch handler is missing one of this functions: pinchStart, pinchMove or pinchEnd");t.fingerDown=e=>{const i=this.currentPointers.filter((t=>t&&t.idx!=e.idx&&t.status==t.stateEnum.DETECT));if(0==i.length)return;const s=[];for(let t of i){let e=null;for(let i of t.eventHistory.toArray())"fingerDown"==i.fingerType&&(e=i);e&&s.push(e)}s.sort(((t,e)=>e.timeStamp-t.timeStamp));for(let i of s){if(e.timeStamp-i.timeStamp>this.pinchInterval)break;if(t.pinchStart(e,i),!e.defaultPrevented)break;clearTimeout(this.currentPointers[e.idx].timeout),clearTimeout(this.currentPointers[i.idx].timeout),this.on("fingerMovingStart",(t=>t.preventDefault()),e.idx),this.on("fingerMovingStart",(t=>t.preventDefault()),i.idx),this.on("fingerMoving",(s=>i&&t.pinchMove(e=s,i)),e.idx),this.on("fingerMoving",(s=>e&&t.pinchMove(e,i=s)),i.idx),this.on("fingerMovingEnd",(s=>{i&&t.pinchEnd(s,i),e=i=null}),e.idx),this.on("fingerMovingEnd",(s=>{e&&t.pinchEnd(e,s),e=i=null}),i.idx);break}},this.on("fingerDown",t)}broadcastOn(t,e){const i=this.eventObservers.get(t);i?i.push(e):this.eventObservers.set(t,[e])}broadcastOff(t,e){w.splitStr(t).forEach((t=>{if(this.eventObservers.has(t))if(e){const i=this.eventObservers.get(t),s=i.indexOf(e);s>-1&&i.splice(s,1),0==i.length&&this.eventObservers.delete(t)}else this.eventObservers.delete(t)}))}broadcast(t){this.eventObservers.has(t.fingerType)&&this.eventObservers.get(t.fingerType).sort(((t,e)=>e.priority-t.priority)).every((e=>(e[t.fingerType](t),!t.defaultPrevented)))}addCurrPointer(t){let e=-1;for(let t=0;t<this.currentPointers.length&&e<0;t++)null==this.currentPointers[t]&&(e=t);return e<0?(this.currentPointers.push(t),e=this.currentPointers.length-1):this.currentPointers[e]=t,e}removeCurrPointer(t){for(this.currentPointers[t]=null;this.currentPointers.length>0&&null==this.currentPointers[this.currentPointers.length-1];)this.currentPointers.pop()}handleEvent(t){"pointerdown"==t.type&&this.target.setPointerCapture(t.pointerId),"pointercancel"==t.type&&console.log(t);let e=!1;for(let i=0;i<this.currentPointers.length&&!e;i++){const s=this.currentPointers[i];s&&(e=s.handleEvent(t),s.isDone()&&this.removeCurrPointer(i))}if(!e){e=new E(this,t.pointerId,{ppmm:this.ppmm}).handleEvent(t)}t.preventDefault()}}class E{constructor(t,e,i){this.parent=t,this.pointerId=e,Object.assign(this,{ppmm:3}),i&&Object.assign(this,i),this.eventHistory=new T(10),this.isActive=!1,this.startTap=0,this.threshold=15,this.eventObservers=new Map,this.isDown=!1,this.done=!1,this.stateEnum={IDLE:0,DETECT:1,HOVER:2,MOVING_START:3,MOVING:4,MOVING_END:5,HOLD:6,TAPS_DETECT:7,SINGLE_TAP:8,DOUBLE_TAP_DETECT:9,DOUBLE_TAP:10},this.status=this.stateEnum.IDLE,this.timeout=null,this.holdTimeoutThreshold=600,this.tapTimeoutThreshold=300,this.upDuration=400,this.oldDownPos={clientX:0,clientY:0},this.movingThreshold=1,this.idx=this.parent.addCurrPointer(this)}static distance(t,e,i,s){return Math.sqrt((i-t)**2+(s-e)**2)}distanceMM(t,e,i,s){return E.distance(t,e,i,s)/this.ppmm}on(t,e){this.eventObservers.set(t,e)}off(t){this.eventObservers.has(t)&&this.eventObservers.delete(t)}addToHistory(t){this.eventHistory.push(t)}prevPointerEvent(){return this.eventHistory.last()}handlePointerDown(t){this.startTap=t.timeStamp}handlePointerUp(t){t.timeStamp,this.startTap}isLikelySamePointer(t){let e=this.pointerId==t.pointerId;if(!e&&!this.isDown&&"pointerdown"==t.type){const i=this.prevPointerEvent();i&&(e=t.pointerType==i.pointerType&&this.distanceMM(t.clientX,t.clientY,i.clientX,i.clientY)<this.threshold)}return e}emit(t){this.eventObservers.has(t.fingerType)&&(this.eventObservers.get(t.fingerType)[t.fingerType](t),t.defaultPrevented)||this.parent.broadcast(t)}createOutputEvent(t,e){const i=t;i.fingerType=e,i.speedX=0,i.speedY=0,i.idx=this.idx;const s=this.prevPointerEvent();if(s&&"pointermove"==t.type){const t=i.timeStamp-s.timeStamp;t>0&&(i.speedX=(i.clientX-s.clientX)/t*1e3,i.speedY=(i.clientY-s.clientY)/t*1e3)}return i}processEvent(t){let e=0;if("pointerdown"==t.type&&(this.oldDownPos.clientX=t.clientX,this.oldDownPos.clientY=t.clientY,this.isDown=!0),"pointerup"!=t.type&&"pointercancel"!=t.type||(this.isDown=!1),"pointermove"==t.type&&this.isDown&&(e=this.distanceMM(t.clientX,t.clientY,this.oldDownPos.clientX,this.oldDownPos.clientY)),"wheel"!=t.type){switch(this.status){case this.stateEnum.HOVER:case this.stateEnum.IDLE:if("pointermove"==t.type)this.emit(this.createOutputEvent(t,"fingerHover")),this.status=this.stateEnum.HOVER;else if("pointerdown"==t.type){if(this.status=this.stateEnum.DETECT,this.emit(this.createOutputEvent(t,"fingerDown")),t.defaultPrevented){this.status=this.stateEnum.MOVING;break}this.timeout=setTimeout((()=>{this.emit(this.createOutputEvent(t,"fingerHold")),t.defaultPrevented&&(this.status=this.stateEnum.IDLE)}),this.holdTimeoutThreshold)}break;case this.stateEnum.DETECT:"pointercancel"==t.type?(clearTimeout(this.timeout),this.status=this.stateEnum.IDLE,this.emit(this.createOutputEvent(t,"fingerHold"))):"pointermove"==t.type&&e>this.movingThreshold?(clearTimeout(this.timeout),this.status=this.stateEnum.MOVING,this.emit(this.createOutputEvent(t,"fingerMovingStart"))):"pointerup"==t.type&&(clearTimeout(this.timeout),this.status=this.stateEnum.TAPS_DETECT,this.timeout=setTimeout((()=>{this.status=this.stateEnum.IDLE,this.emit(this.createOutputEvent(t,"fingerSingleTap"))}),this.tapTimeoutThreshold));break;case this.stateEnum.TAPS_DETECT:"pointerdown"==t.type?(clearTimeout(this.timeout),this.status=this.stateEnum.DOUBLE_TAP_DETECT,this.timeout=setTimeout((()=>{this.emit(this.createOutputEvent(t,"fingerHold")),t.defaultPrevented&&(this.status=this.stateEnum.IDLE)}),this.tapTimeoutThreshold)):"pointermove"==t.type&&e>this.movingThreshold&&(clearTimeout(this.timeout),this.status=this.stateEnum.IDLE,this.emit(this.createOutputEvent(t,"fingerHover")));break;case this.stateEnum.DOUBLE_TAP_DETECT:"pointerup"!=t.type&&"pointercancel"!=t.type||(clearTimeout(this.timeout),this.status=this.stateEnum.IDLE,this.emit(this.createOutputEvent(t,"fingerDoubleTap")));break;case this.stateEnum.DOUBLE_TAP_DETECT:"pointermove"==t.type&&e>this.movingThreshold&&(this.status=this.stateEnum.MOVING,this.emit(this.createOutputEvent(t,"fingerMovingStart")));break;case this.stateEnum.MOVING:"pointermove"==t.type?this.emit(this.createOutputEvent(t,"fingerMoving")):"pointerup"!=t.type&&"pointercancel"!=t.type||(this.status=this.stateEnum.IDLE,this.emit(this.createOutputEvent(t,"fingerMovingEnd")));break;default:console.log("ERROR "+this.status),console.log(t)}this.addToHistory(t)}else this.emit(this.createOutputEvent(t,"mouseWheel"))}handleEvent(t){let e=!1;return this.isLikelySamePointer(t)&&(this.pointerId=t.pointerId,this.processEvent(t),e=!0),e}isDone(){return this.status==this.stateEnum.IDLE}}class T{constructor(t){if("number"!=typeof t||!Number.isInteger(t)||t<1)throw new TypeError("Invalid capacity");this.buffer=new Array(t),this.capacity=t,this.first=0,this.size=0}clear(){this.first=0,this.size=0}empty(){return 0==this.size}size(){return this.size}capacity(){return this.capacity}first(){let t=null;return this.size>0&&(t=this.buffer[this.first]),t}last(){let t=null;return this.size>0&&(t=this.buffer[(this.first+this.size-1)%this.capacity]),t}enqueue(t){this.first=this.first>0?this.first-1:this.first=this.capacity-1,this.buffer[this.first]=t,this.size<this.capacity&&this.size++}push(t){this.size==this.capacity?(this.buffer[this.first]=t,this.first=(this.first+1)%this.capacity):(this.buffer[(this.first+this.size)%this.capacity]=t,this.size++)}dequeue(){if(0==this.size)throw new RangeError("Dequeue on empty buffer");const t=this.buffer[(this.first+this.size-1)%this.capacity];return this.size--,t}pop(){return this.dequeue()}shift(){if(0==this.size)throw new RangeError("Shift on empty buffer");const t=this.buffer[this.first];return this.first==this.capacity-1?this.first=0:this.first++,this.size--,t}get(t,e){if(0==this.size&&0==t&&(null==e||0==e))return[];if("number"!=typeof t||!Number.isInteger(t)||t<0)throw new TypeError("Invalid start value");if(t>=this.size)throw new RangeError("Start index past end of buffer: "+t);if(null==e)return this.buffer[(this.first+t)%this.capacity];if("number"!=typeof e||!Number.isInteger(e)||e<0)throw new TypeError("Invalid end value");if(e>=this.size)throw new RangeError("End index past end of buffer: "+e);return this.first+t>=this.capacity&&(t-=this.capacity,e-=this.capacity),this.first+e<this.capacity?this.buffer.slice(this.first+t,this.first+e+1):this.buffer.slice(this.first+t,this.capacity).concat(this.buffer.slice(0,this.first+e+1-this.capacity))}toArray(){return 0==this.size?[]:this.get(0,this.size-1)}}t.Camera=s,t.Canvas=l,t.Layer=h,t.Layout=a,t.OpenLIME=class{constructor(t,e){if(Object.assign(this,{background:null,canvas:{},controllers:[],camera:new s}),"string"==typeof t&&(t=document.querySelector(t)),!t)throw"Missing element parameter";Object.assign(this,e),this.background&&(t.style.background=this.background),this.containerElement=t,this.canvasElement=t.querySelector("canvas"),this.canvasElement||(this.canvasElement=document.createElement("canvas"),t.prepend(this.canvasElement)),this.overlayElement=document.createElement("div"),this.overlayElement.classList.add("openlime-overlay"),this.containerElement.appendChild(this.overlayElement),this.canvas=new l(this.canvasElement,this.overlayElement,this.camera,this.canvas),this.canvas.addEvent("update",(()=>{this.redraw()})),this.camera.addEvent("update",(()=>{this.redraw()})),this.pointerManager=new w(this.overlayElement),this.canvasElement.addEventListener("contextmenu",(t=>(t.preventDefault(),!1))),new ResizeObserver((t=>{for(let e of t)this.resize(e.contentRect.width,e.contentRect.height),this.processEvent("resize",{},e.contentRect.width,e.contentRect.height)})).observe(this.canvasElement),this.resize(this.canvasElement.clientWidth,this.canvasElement.clientHeight)}addLayer(t,e){canvas.addLayer(t,e)}resize(t,e){this.canvasElement.width=t,this.canvasElement.height=e,this.camera.setViewport({x:0,y:0,dx:t,dy:e,w:t,h:e}),this.canvas.prefetch(),this.redraw()}redraw(){this.animaterequest||(this.animaterequest=requestAnimationFrame((t=>{this.draw(t)})))}draw(t){t||(t=performance.now()),this.animaterequest=null;this.camera.viewport,this.camera.getCurrentTransform(t);this.canvas.draw(t)||this.redraw()}processEvent(t,e,i,s,r){let n=Object.values(this.canvas.layers).sort(((t,e)=>e.zindex-t.zindex));n.push(this);for(let i of n)for(let s of i.controllers)if(s.active&&s[t]&&s[t](e),e.defaultPrevented)return}},t.RTILayer=p,t.Raster=r,t.Shader=n,t.Transform=i,t.UIBasic=class{constructor(t,e){let i=t.camera;Object.assign(this,{lime:t,camera:t.camera,skin:"skin.svg",autoFit:!0,actions:{home:{title:"Home",display:!0,task:t=>{i.boundingBox&&i.fitCameraBox(250)}},fullscreen:{title:"Fullscreen",display:!0,task:t=>{this.toggleFullscreen()}},layers:{title:"Layers",display:"auto",task:t=>{this.toggleLayers(t)}},zoomin:{title:"Zoom in",display:!1,task:t=>{i.deltaZoom(250,1.25,0,0)}},zoomout:{title:"Zoom out",display:!1,task:t=>{i.deltaZoom(250,.8,0,0)}},rotate:{title:"Rotate",display:!1,task:t=>{i.rotate(250,-45)}},light:{title:"Light",display:"auto",task:t=>{this.toggleLightController()}},ruler:{title:"Ruler",display:!1,task:t=>{this.startRuler()}}},viewport:[0,0,0,0]}),Object.assign(this,e),this.autoFit&&this.lime.canvas.addEvent("updateSize",(()=>this.lime.camera.fitCameraBox(0))),this.menu=[],this.menu.push({section:"Layers"});for(let[t,e]of Object.entries(this.lime.canvas.layers)){let i=[];for(let s of e.getModes()){let r={button:s,mode:s,layer:t,onclick:()=>{e.setMode(s)}};"specular"==s&&(r.list=[{slider:"",oninput:t=>{e.shader.setSpecularExp(t.target.value)}}]),i.push(r)}this.menu.push({button:e.label||t,onclick:()=>{this.setLayer(e)},list:i,layer:t})}queueMicrotask?queueMicrotask((()=>{this.init()})):setTimeout((()=>{this.init()}),0)}init(){(async()=>{let t=new b(this.lime.camera,{priority:-1e3});this.lime.pointerManager.onEvent(t),this.actions.layers&&"auto"==this.actions.layers.display&&(this.actions.layers.display=this.lime.canvas.layers.length>0),this.createMenu(),this.updateMenu();let e=[];for(let[t,i]of Object.entries(this.lime.canvas.layers))i.controls.light&&e.push(i);if(e.length){this.actions.light&&"auto"===this.actions.light.display&&(this.actions.light.display=!0);let t=new v(((t,i)=>{for(let s of e)s.setLight([t,i],0)}),{active:!1,control:"light"});t.priority=0,this.lime.pointerManager.onEvent(t);for(let i of e)i.setLight([.5,.5],0),i.controllers.push(t)}this.skin&&await this.loadSkin(),this.setupActions();for(let t of Object.values(this.lime.canvas.layers))break;1==this.actions.light.active&&this.toggleLightController()})().catch((t=>{throw console.log(t),Error("Something failed")}))}async loadSkin(){var t=await fetch(this.skin);if(!t.ok)throw Error("Failed loading "+url+": "+t.statusText);let e=await t.text(),i=(new DOMParser).parseFromString(e,"image/svg+xml").documentElement,s=document.createElement("div");s.classList.add("openlime-toolbar"),this.lime.containerElement.appendChild(s);for(let[t,e]of Object.entries(this.actions)){if(!0!==e.display)continue;let r=document.createElementNS("http://www.w3.org/2000/svg","svg");s.appendChild(r);let n=i.querySelector(".openlime-"+t).cloneNode(!0);if(!n)continue;r.appendChild(n);let a=n.getBBox(),o=n.transform.baseVal;0==o.numberOfItems&&o.appendItem(r.createSVGTransform()),o.getItem(0).setTranslate(-a.x,-a.y),r.setAttribute("viewBox",`0 0 ${a.width} ${a.height}`),r.setAttribute("preserveAspectRatio","xMidYMid meet")}}setupActions(){for(let[t,e]of Object.entries(this.actions)){let i=this.lime.containerElement.querySelector(".openlime-"+t);i&&i.addEventListener("click",e.task)}let t=document.querySelectorAll(".openlime-layers-button");for(let e of t){let t=e.getAttribute("data-layer");t&&e.addEventListener("click",(()=>{this.setLayer(this.lime.layers[t])}))}}toggleLightController(){let t=this.lime.containerElement.classList.toggle("openlime-light-active");this.lightActive=t;for(let e of Object.values(this.lime.canvas.layers))for(let i of e.controllers)"light"==i.control&&(i.active=t)}toggleFullscreen(){let t=this.lime.canvasElement,e=this.lime.containerElement;e.classList.toggle("openlime-fullscreen-active")?(e.requestFullscreen||e.webkitRequestFullscreen||e.mozRequestFullScreen||e.msRequestFullscreen).call(e):((document.exitFullscreen||document.webkitExitFullscreen||document.mozCancelFullScreen||document.msExitFullscreen).call(document),this.lime.resize(t.offsetWidth,t.offsetHeight));this.lime.resize(t.offsetWidth,t.offsetHeight)}startRuler(){}endRuler(){}createEntry(t){"id"in t||(t.id="entry_"+this.entry_count++);let e=`id="${t.id}"`,i="";if("title"in t)i+=`<h2 ${e} class="openlime-title">${t.title}</h2>`;else if("section"in t)i+=`<h3 ${e} class="openlime-section">${t.section}</h3>`;else if("html"in t)i+=`<div ${e}>${t.html}</div>`;else if("button"in t){i+=`<a href="#" ${e} ${"group"in t?`data-group="${t.group}"`:""} ${"layer"in t?`data-layer="${t.layer}"`:""} ${"mode"in t?`data-mode="${t.mode}"`:""} class="openlime-button">${t.button}</a>`}else"slider"in t&&(i+=`<input type="range" min="1" max="100" value="50" class="openlime-slider" ${e}>`);if("list"in t){let e='<div class="openlime-list">';for(let i of t.list)e+=this.createEntry(i);e+="</div>",i+=e}return i}addEntryCallbacks(t){if(t.element=this.layerMenu.querySelector("#"+t.id),t.onclick&&t.element.addEventListener("click",(e=>{t.onclick(),t.element.classList.add("active"),this.updateMenu()})),t.oninput&&t.element.addEventListener("input",t.oninput),"list"in t)for(let e of t.list)this.addEntryCallbacks(e)}updateEntry(t){let e=t.element,i=(e.getAttribute("data-group"),e.getAttribute("data-layer")),s=e.getAttribute("data-mode"),r=i&&this.lime.canvas.layers[i].visible&&(!s||this.lime.canvas.layers[i].getMode()==s);if(t.element.classList.toggle("active",r),"list"in t)for(let e of t.list)this.updateEntry(e)}updateMenu(){for(let t of this.menu)this.updateEntry(t)}createMenu(){this.entry_count=0;let t='<div class="openlime-layers-menu">';for(let e of this.menu)t+=this.createEntry(e);t+="</div>";let e=document.createElement("template");e.innerHTML=t.trim(),this.layerMenu=e.content.firstChild,this.lime.containerElement.appendChild(this.layerMenu);for(let t of this.menu)this.addEntryCallbacks(t)}toggleLayers(t){this.layerMenu.classList.toggle("open")}setLayer(t){"string"==typeof t&&(t=this.lime.canvas.layers[t]),this.activeLayer=t;for(let e of Object.values(this.lime.canvas.layers)){e.setVisible(e==t);for(let i of e.controllers)"light"==i.control&&(i.active=this.lightActive&&e==t)}this.lime.redraw(),this.updateMenu()}closeLayersMenu(){this.layerMenu.style.display="none"}},Object.defineProperty(t,"__esModule",{value:!0})}));
